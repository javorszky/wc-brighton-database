<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>"Things you didn't know you need to know about WordPress and databases" talk by Gabor Javorszky – WordCamp Brighton, 18th August 2017</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>Things you didn't know you need to know about WordPress and databases</h2>
					<p>by Gabor Javorszky</p>
					<p class="fragment">crash course into database architecture</p>
					<aside class="notes">
						<p><small>(full disclosure: I'm not a certified DB architect)</small></p>
					</aside>
				</section>

				<section>
					<h1>Assumptions</h1>
					<ol>
						<li>
							<p>Site is large with lots of data</p>
						</li>
						<li>
							<p>potentially one with WooCommerce</p>
						</li>
					</ol>
				</section>

				<section>
					<h2>common (slow) queries</h2>
					<blockquote>get me all the orders for user 4</blockquote>
					<blockquote>get me all subscriptions where the next payment date is between X and Y</blockquote>
					<blockquote>get me all orders where the total is $19.92</blockquote>
					<blockquote>get me the sum of all order totals where the order date is in May and order by order total. or date</blockquote>
				</section>

				<section>
					<blockquote>basically doing anything on the admin area</blockquote>
				</section>

				<section>
					<p>All of those are going to be</p>
					<p class="fragment">...really...</p>
					<p class="fragment">...slow.</p>
				</section>

				<section>
					<p>select statements indexing vs order by / group by optimization</p>
					<p>indexes are at the heart of everything</p>
					<p>indexes are based on good database design</p>
				</section>

				<section>
					<p>When to use existing / built in functionality to store data and when to create new tables.</p>
				</section>

				<section>
					<p>additionally when you create new tables, what should they look like?</p>
					<p>very much depends on your use case and how you're going to interact with the data</p>
				</section>


				<section>
					<h1>Tables, rows, columns, data types</h1>
					<ul>
						<li>integer, signed, unsigned</li>
						<li>text, varchar, longtext</li>
						<li>date, timestamp, datetime</li>
					</ul>
				</section>

				<section>
					<h1>Indexes</h1>
					<p>What are they?</p>
					<p>Why are they important?</p>
					<p>How do they work?</p>
					<p>Indexable, unindexable (looking at you, postmeta value!)</p>
				</section>

				<section>
					<h1>WP DB - posts</h1>
					<p><img src="assets/pix/posts.png" alt=""></p>
				</section>

				<section>
					How to make queries fast?

					Know how the optimizer works!

					Regarding NULLs
					<blockquote cite="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-queries.html">If an indexed column cannot contain any NULL values, declare it as NOT NULL when you create the table. The optimizer can better determine which index is most effective to use for a query, when it knows whether each column contains NULL values <footer><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-queries.html">https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-queries.html</a></footer></blockquote>
					<aside class="notes">https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-queries.html</aside>

				</section>
				<section>
					If the table has a multiple-column index, any leftmost prefix of the index can be used by the optimizer to look up rows. For example, if you have a three-column index on (col1, col2, col3), you have indexed search capabilities on (col1), (col1, col2), and (col1, col2, col3). For more information, see Section 8.3.5, “Multiple-Column Indexes”.


					<p>https://dev.mysql.com/doc/refman/5.7/en/mysql-indexes.html</p>
				</section>
				<section>
					<p>To retrieve rows from other tables when performing joins. MySQL can use indexes on columns more efficiently if they are declared as the same type and size. In this context, VARCHAR and CHAR are considered the same if they are declared as the same size. For example, VARCHAR(10) and CHAR(10) are the same size, but VARCHAR(10) and CHAR(15) are not.

					For comparisons between nonbinary string columns, both columns should use the same character set. For example, comparing a utf8 column with a latin1 column precludes use of an index.

					Comparison of dissimilar columns (comparing a string column to a temporal or numeric column, for example) may prevent use of indexes if values cannot be compared directly without conversion. For a given value such as 1 in the numeric column, it might compare equal to any number of values in the string column such as '1', ' 1', '00001', or '01.e1'. This rules out use of any indexes for the string column.</p>

					<p>https://dev.mysql.com/doc/refman/5.7/en/mysql-indexes.html</p>

					<p>MySQL can use multiple-column indexes for queries that test all the columns in the index, or queries that test just the first column, the first two columns, the first three columns, and so on. If you specify the columns in the right order in the index definition, a single composite index can speed up several kinds of queries on the same table.</p>
				</section>

				<section>
					<p>Indexes are less important for queries on small tables, or big tables where report queries process most or all of the rows. When a query needs to access most of the rows, reading sequentially is faster than working through an index. Sequential reads minimize disk seeks, even if not all the rows are needed for the query. See Section 8.2.1.19, “Avoiding Full Table Scans” for details.</p>
				</section>

				<section>
					<p>If the table has a multiple-column index, any leftmost prefix of the index can be used by the optimizer to look up rows. For example, if you have a three-column index on (col1, col2, col3), you have indexed search capabilities on (col1), (col1, col2), and (col1, col2, col3).</p>
				</section>



			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
